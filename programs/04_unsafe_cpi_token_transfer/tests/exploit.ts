import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { Keypair, LAMPORTS_PER_SOL, PublicKey, SystemProgram } from "@solana/web3.js";
import { createMint, createAccount, mintTo, getAccount, TOKEN_PROGRAM_ID } from "@solana/spl-token";
import { expect } from "chai";

describe("04_unsafe_cpi_token_transfer", () => {
    const provider = anchor.AnchorProvider.env();
    anchor.setProvider(provider);

    const program = anchor.workspace.UnsafeCpiTokenTransfer as Program<any>;

    let authority: Keypair;
    let legitimateRecipient: Keypair;
    let attacker: Keypair;

    let mint: PublicKey;
    let authorityTokenAccount: PublicKey;
    let recipientTokenAccount: PublicKey;
    let attackerTokenAccount: PublicKey;
    let statePda: PublicKey;

    const INITIAL_AMOUNT = 10000;

    before(async () => {
        authority = Keypair.generate();
        legitimateRecipient = Keypair.generate();
        attacker = Keypair.generate();

        for (const keypair of [authority, legitimateRecipient, attacker]) {
            const airdrop = await provider.connection.requestAirdrop(
                keypair.publicKey,
                5 * LAMPORTS_PER_SOL
            );
            await provider.connection.confirmTransaction(airdrop);
        }

        // Create token mint
        mint = await createMint(
            provider.connection,
            authority,
            authority.publicKey,
            null,
            9
        );

        // Create token accounts
        authorityTokenAccount = await createAccount(
            provider.connection,
            authority,
            mint,
            authority.publicKey
        );

        recipientTokenAccount = await createAccount(
            provider.connection,
            legitimateRecipient,
            mint,
            legitimateRecipient.publicKey
        );

        attackerTokenAccount = await createAccount(
            provider.connection,
            attacker,
            mint,
            attacker.publicKey
        );

        // Mint tokens to authority
        await mintTo(
            provider.connection,
            authority,
            mint,
            authorityTokenAccount,
            authority,
            INITIAL_AMOUNT
        );

        // Derive state PDA
        [statePda] = PublicKey.findProgramAddressSync(
            [Buffer.from("state")],
            program.programId
        );
    });

    describe("Setup: Initialize state with legitimate recipient", () => {
        it("Initialize state PDA", async () => {
            await program.methods
                .initialize(legitimateRecipient.publicKey)
                .accounts({
                    state: statePda,
                    authority: authority.publicKey,
                    systemProgram: SystemProgram.programId,
                })
                .signers([authority])
                .rpc();

            const state = await program.account.state.fetch(statePda);
            expect(state.recipient.toString()).to.equal(legitimateRecipient.publicKey.toString());
        });
    });

    describe("Vulnerable: Fund Redirection Attack", () => {
        it("Attacker redirects funds to their own account", async () => {
            const transferAmount = 1000;

            const attackerBefore = await getAccount(provider.connection, attackerTokenAccount);
            const recipientBefore = await getAccount(provider.connection, recipientTokenAccount);

            // Attacker passes their own token account instead of recipient's
            await program.methods
                .vulnerableTransfer(new anchor.BN(transferAmount))
                .accounts({
                    state: statePda,
                    from: authorityTokenAccount,
                    to: attackerTokenAccount, // ATTACK: Attacker's account, not recipient's
                    authority: authority.publicKey,
                    tokenProgram: TOKEN_PROGRAM_ID,
                })
                .signers([authority])
                .rpc();

            const attackerAfter = await getAccount(provider.connection, attackerTokenAccount);
            const recipientAfter = await getAccount(provider.connection, recipientTokenAccount);

            // Attacker received the funds
            expect(Number(attackerAfter.amount)).to.equal(
                Number(attackerBefore.amount) + transferAmount
            );

            // Legitimate recipient received nothing
            expect(Number(recipientAfter.amount)).to.equal(Number(recipientBefore.amount));
        });
    });

    describe("Secure: Fund Redirection Prevented", () => {
        before(async () => {
            // Mint more tokens for secure tests
            await mintTo(
                provider.connection,
                authority,
                mint,
                authorityTokenAccount,
                authority,
                INITIAL_AMOUNT
            );
        });

        it("Attacker cannot pass their own account (constraint fails)", async () => {
            try {
                await program.methods
                    .secureTransfer(new anchor.BN(1000))
                    .accounts({
                        state: statePda,
                        from: authorityTokenAccount,
                        to: attackerTokenAccount, // Attacker's account - should fail
                        authority: authority.publicKey,
                        tokenProgram: TOKEN_PROGRAM_ID,
                    })
                    .signers([authority])
                    .rpc();

                expect.fail("Should have thrown - wrong recipient");
            } catch (error: any) {
                expect(error.message).to.include("constraint");
            }
        });

        it("Legitimate transfer succeeds with correct recipient", async () => {
            const transferAmount = 1000;

            const recipientBefore = await getAccount(provider.connection, recipientTokenAccount);

            await program.methods
                .secureTransfer(new anchor.BN(transferAmount))
                .accounts({
                    state: statePda,
                    from: authorityTokenAccount,
                    to: recipientTokenAccount, // Correct recipient
                    authority: authority.publicKey,
                    tokenProgram: TOKEN_PROGRAM_ID,
                })
                .signers([authority])
                .rpc();

            const recipientAfter = await getAccount(provider.connection, recipientTokenAccount);

            expect(Number(recipientAfter.amount)).to.equal(
                Number(recipientBefore.amount) + transferAmount
            );
        });
    });

    describe("Security Comparison", () => {
        it("Demonstrates the core difference", () => {
            console.log("\n=== CPI Token Transfer Security ===\n");

            console.log("VULNERABLE PATTERN:");
            console.log("  pub to: AccountInfo<'info>");
            console.log("  Risk: Accepts any account as destination");
            console.log("  Attack: Substitute attacker's token account\n");

            console.log("SECURE PATTERN:");
            console.log("  #[account(mut, constraint = to.owner == state.recipient)]");
            console.log("  pub to: Account<'info, TokenAccount>");
            console.log("  Protection: Validates destination owner matches stored recipient\n");

            console.log("KEY INSIGHT:");
            console.log("  AccountInfo -> NO validation");
            console.log("  Account<TokenAccount> + constraint -> VERIFIED recipient");
        });
    });
});
