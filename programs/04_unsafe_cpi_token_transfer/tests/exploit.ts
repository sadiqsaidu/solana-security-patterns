import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { 
    Keypair, 
    PublicKey, 
    SystemProgram, 
    LAMPORTS_PER_SOL,
} from "@solana/web3.js";
import { 
    TOKEN_PROGRAM_ID,
    createMint,
    createAccount,
    mintTo,
    getAccount,
} from "@solana/spl-token";
import { expect } from "chai";

describe("04_unsafe_cpi_token_transfer", () => {
    const provider = anchor.AnchorProvider.env();
    anchor.setProvider(provider);

    const program = anchor.workspace.UnsafeCpiTokenTransfer as Program<any>;
    
    // Test accounts
    let authority: Keypair;
    let treasury: Keypair;
    let legitimateRecipient: Keypair;
    let attacker: Keypair;
    
    // Token accounts
    let mint: PublicKey;
    let authorityTokenAccount: PublicKey;
    let treasuryTokenAccount: PublicKey;
    let recipientTokenAccount: PublicKey;
    let attackerTokenAccount: PublicKey;
    
    // PDAs
    let splitterPda: PublicKey;
    let splitterBump: number;

    const INITIAL_MINT_AMOUNT = 10000;
    const RECIPIENT_SHARE_BPS = 3000; // 30%

    before(async () => {
        // Create keypairs
        authority = Keypair.generate();
        treasury = Keypair.generate();
        legitimateRecipient = Keypair.generate();
        attacker = Keypair.generate();

        // Airdrop SOL to all accounts
        for (const keypair of [authority, treasury, legitimateRecipient, attacker]) {
            const airdrop = await provider.connection.requestAirdrop(
                keypair.publicKey,
                5 * LAMPORTS_PER_SOL
            );
            await provider.connection.confirmTransaction(airdrop);
        }

        // Create token mint
        mint = await createMint(
            provider.connection,
            authority,
            authority.publicKey,
            null,
            9
        );

        // Create token accounts
        authorityTokenAccount = await createAccount(
            provider.connection,
            authority,
            mint,
            authority.publicKey
        );

        treasuryTokenAccount = await createAccount(
            provider.connection,
            treasury,
            mint,
            treasury.publicKey
        );

        recipientTokenAccount = await createAccount(
            provider.connection,
            legitimateRecipient,
            mint,
            legitimateRecipient.publicKey
        );

        attackerTokenAccount = await createAccount(
            provider.connection,
            attacker,
            mint,
            attacker.publicKey
        );

        // Mint tokens to authority
        await mintTo(
            provider.connection,
            authority,
            mint,
            authorityTokenAccount,
            authority,
            INITIAL_MINT_AMOUNT
        );

        // Derive splitter PDA
        [splitterPda, splitterBump] = PublicKey.findProgramAddressSync(
            [Buffer.from("splitter"), authority.publicKey.toBuffer()],
            program.programId
        );

        console.log(`ğŸ”§ Setup complete:`);
        console.log(`   Authority: ${authority.publicKey}`);
        console.log(`   Treasury: ${treasury.publicKey}`);
        console.log(`   Legitimate Recipient: ${legitimateRecipient.publicKey}`);
        console.log(`   Attacker: ${attacker.publicKey}`);
        console.log(`   Mint: ${mint}`);
        console.log(`   Initial tokens: ${INITIAL_MINT_AMOUNT}`);
    });

    describe("Setup: Initialize payment splitter", () => {
        it("Initialize splitter with legitimate recipient", async () => {
            await program.methods
                .initializeSplitter(RECIPIENT_SHARE_BPS)
                .accounts({
                    splitter: splitterPda,
                    authority: authority.publicKey,
                    treasury: treasury.publicKey,
                    recipient: legitimateRecipient.publicKey,
                    systemProgram: SystemProgram.programId,
                })
                .signers([authority])
                .rpc();

            const splitter = await program.account.splitter.fetch(splitterPda);
            
            console.log(`\nâœ… Splitter initialized:`);
            console.log(`   Recipient: ${splitter.recipient}`);
            console.log(`   Recipient share: ${splitter.recipientShareBps} bps (${splitter.recipientShareBps / 100}%)`);
            
            expect(splitter.recipient.toString()).to.equal(legitimateRecipient.publicKey.toString());
        });
    });

    describe("âš ï¸  EXPLOIT: Attacker redirects funds via vulnerable_split_payment", () => {
        /**
         * ATTACK EXPLANATION:
         * 
         * The vulnerable_split_payment instruction doesn't verify that:
         * 1. recipient_token_account.owner == splitter.recipient
         * 2. The token program is the real SPL Token program
         * 
         * Attack flow:
         * 1. Splitter is set up with legitimate_recipient
         * 2. Attacker calls vulnerable_split_payment
         * 3. Attacker passes their OWN token account as recipient_token_account
         * 4. Funds go to attacker instead of legitimate recipient!
         * 
         * This is similar to Crema Finance where fake accounts were used in CPIs.
         */

        it("âŒ EXPLOIT SUCCEEDS: Attacker receives funds meant for recipient", async () => {
            const splitAmount = 1000;
            const expectedAttackerAmount = (splitAmount * RECIPIENT_SHARE_BPS) / 10000; // 30%

            // Get balances before
            const attackerBefore = await getAccount(provider.connection, attackerTokenAccount);
            const recipientBefore = await getAccount(provider.connection, recipientTokenAccount);

            console.log(`\nğŸ¯ Attack: Redirect payment to attacker`);
            console.log(`   Split amount: ${splitAmount} tokens`);
            console.log(`   Attacker should steal: ${expectedAttackerAmount} tokens (30%)`);
            console.log(`   Attacker balance before: ${attackerBefore.amount}`);
            console.log(`   Legitimate recipient balance before: ${recipientBefore.amount}`);

            // The attack: pass attacker's token account instead of recipient's
            await program.methods
                .vulnerableSplitPayment(new anchor.BN(splitAmount))
                .accounts({
                    splitter: splitterPda,
                    sourceTokenAccount: authorityTokenAccount,
                    recipientTokenAccount: attackerTokenAccount,  // âŒ ATTACKER'S ACCOUNT!
                    treasuryTokenAccount: treasuryTokenAccount,
                    authority: authority.publicKey,
                    tokenProgram: TOKEN_PROGRAM_ID,
                })
                .signers([authority])
                .rpc();

            // Get balances after
            const attackerAfter = await getAccount(provider.connection, attackerTokenAccount);
            const recipientAfter = await getAccount(provider.connection, recipientTokenAccount);

            console.log(`\nğŸš¨ EXPLOIT SUCCEEDED!`);
            console.log(`   Attacker balance after: ${attackerAfter.amount} (+${Number(attackerAfter.amount) - Number(attackerBefore.amount)})`);
            console.log(`   Legitimate recipient: ${recipientAfter.amount} (unchanged!)`);
            console.log(`   Funds meant for ${legitimateRecipient.publicKey}`);
            console.log(`   Actually went to ${attacker.publicKey}`);

            // Verify attacker received the funds
            expect(Number(attackerAfter.amount)).to.equal(
                Number(attackerBefore.amount) + expectedAttackerAmount
            );
            // Verify legitimate recipient got nothing
            expect(Number(recipientAfter.amount)).to.equal(Number(recipientBefore.amount));
        });

        it("âš ï¸  Attacker could also pass fake token program", async () => {
            // This demonstrates that the token_program is also unverified
            // In a real attack, a malicious program could:
            // - Ignore the transfer and do nothing (funds stay in source)
            // - Transfer to a different account
            // - Execute arbitrary code

            console.log(`\nâš ï¸  Additional vulnerability: Unverified token program`);
            console.log(`   The vulnerable instruction accepts any program as token_program`);
            console.log(`   A malicious program could:`);
            console.log(`   - Drain additional funds`);
            console.log(`   - Execute arbitrary logic`);
            console.log(`   - Manipulate account states`);
        });
    });

    describe("âœ… SECURE: Attacker cannot redirect funds via secure_split_payment", () => {
        before(async () => {
            // Mint more tokens for secure tests
            await mintTo(
                provider.connection,
                authority,
                mint,
                authorityTokenAccount,
                authority,
                INITIAL_MINT_AMOUNT
            );
        });

        it("âŒ Attacker cannot pass their token account (constraint fails)", async () => {
            try {
                await program.methods
                    .secureSplitPayment(new anchor.BN(1000))
                    .accounts({
                        splitter: splitterPda,
                        sourceTokenAccount: authorityTokenAccount,
                        recipientTokenAccount: attackerTokenAccount,  // Try to use attacker's account
                        treasuryTokenAccount: treasuryTokenAccount,
                        authority: authority.publicKey,
                        treasury: treasury.publicKey,
                        recipient: legitimateRecipient.publicKey,
                        tokenProgram: TOKEN_PROGRAM_ID,
                    })
                    .signers([authority])
                    .rpc();

                expect.fail("Should have thrown an error");
            } catch (error: any) {
                console.log(`\nâœ… Attack blocked: Token account owner mismatch`);
                console.log(`   Attacker's account owner: ${attacker.publicKey}`);
                console.log(`   Expected owner: ${legitimateRecipient.publicKey}`);
                expect(error.toString()).to.include("InvalidRecipient");
            }
        });

        it("âŒ Attacker cannot pass mismatched mint (constraint fails)", async () => {
            // Create a different mint
            const fakeMint = await createMint(
                provider.connection,
                attacker,
                attacker.publicKey,
                null,
                9
            );

            const fakeTokenAccount = await createAccount(
                provider.connection,
                attacker,
                fakeMint,
                legitimateRecipient.publicKey  // Correct owner, wrong mint
            );

            try {
                await program.methods
                    .secureSplitPayment(new anchor.BN(1000))
                    .accounts({
                        splitter: splitterPda,
                        sourceTokenAccount: authorityTokenAccount,
                        recipientTokenAccount: fakeTokenAccount,  // Wrong mint!
                        treasuryTokenAccount: treasuryTokenAccount,
                        authority: authority.publicKey,
                        treasury: treasury.publicKey,
                        recipient: legitimateRecipient.publicKey,
                        tokenProgram: TOKEN_PROGRAM_ID,
                    })
                    .signers([authority])
                    .rpc();

                expect.fail("Should have thrown an error");
            } catch (error: any) {
                console.log(`\nâœ… Attack blocked: Mint mismatch detected`);
                expect(error.toString()).to.include("MintMismatch");
            }
        });

        it("âœ… Legitimate payment goes to correct recipient", async () => {
            const splitAmount = 1000;
            const expectedRecipientAmount = (splitAmount * RECIPIENT_SHARE_BPS) / 10000;
            const expectedTreasuryAmount = splitAmount - expectedRecipientAmount;

            const recipientBefore = await getAccount(provider.connection, recipientTokenAccount);
            const treasuryBefore = await getAccount(provider.connection, treasuryTokenAccount);

            await program.methods
                .secureSplitPayment(new anchor.BN(splitAmount))
                .accounts({
                    splitter: splitterPda,
                    sourceTokenAccount: authorityTokenAccount,
                    recipientTokenAccount: recipientTokenAccount,  // âœ… Correct account
                    treasuryTokenAccount: treasuryTokenAccount,
                    authority: authority.publicKey,
                    treasury: treasury.publicKey,
                    recipient: legitimateRecipient.publicKey,
                    tokenProgram: TOKEN_PROGRAM_ID,
                })
                .signers([authority])
                .rpc();

            const recipientAfter = await getAccount(provider.connection, recipientTokenAccount);
            const treasuryAfter = await getAccount(provider.connection, treasuryTokenAccount);

            console.log(`\nâœ… Secure payment succeeded:`);
            console.log(`   Recipient received: ${Number(recipientAfter.amount) - Number(recipientBefore.amount)} tokens`);
            console.log(`   Treasury received: ${Number(treasuryAfter.amount) - Number(treasuryBefore.amount)} tokens`);

            expect(Number(recipientAfter.amount)).to.equal(
                Number(recipientBefore.amount) + expectedRecipientAmount
            );
            expect(Number(treasuryAfter.amount)).to.equal(
                Number(treasuryBefore.amount) + expectedTreasuryAmount
            );
        });
    });

    describe("ğŸ“Š Security Comparison Summary", () => {
        it("Summary of CPI security patterns", () => {
            console.log(`
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    CPI SECURITY COMPARISON SUMMARY                    â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  VULNERABLE (unvalidated CPI)                                         â•‘
â•‘  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                         â•‘
â•‘  âŒ Uses AccountInfo for token accounts (no type checking)            â•‘
â•‘  âŒ No verification of token account owners                           â•‘
â•‘  âŒ No mint consistency check                                          â•‘
â•‘  âŒ Token program not verified (could be malicious)                   â•‘
â•‘                                                                       â•‘
â•‘  ATTACK RESULT: Attacker redirects 300 tokens to themselves!          â•‘
â•‘                                                                       â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  SECURE (validated CPI)                                               â•‘
â•‘  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                               â•‘
â•‘  âœ… Uses Account<TokenAccount> (type verification)                    â•‘
â•‘  âœ… Constraints verify token account owners                            â•‘
â•‘  âœ… Mint consistency enforced across accounts                          â•‘
â•‘  âœ… Program<Token> verifies real SPL Token program                    â•‘
â•‘                                                                       â•‘
â•‘  PROTECTION: All attacks blocked at constraint level                  â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

KEY LESSONS:
1. Always use Account<TokenAccount> instead of AccountInfo for tokens
2. Verify token account owners match expected parties
3. Ensure all token accounts use the same mint
4. Use Program<Token> to verify the token program ID
5. Never allow arbitrary CPI targets - hardcode or validate
            `);
        });
    });
});
