import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { Keypair, LAMPORTS_PER_SOL, PublicKey, SystemProgram } from "@solana/web3.js";
import { expect } from "chai";

describe("05_integer_overflow_demo", () => {
    const provider = anchor.AnchorProvider.env();
    anchor.setProvider(provider);

    const program = anchor.workspace.IntegerOverflowDemo as Program<any>;

    let authority: Keypair;
    let statePda: PublicKey;

    const U64_MAX = new anchor.BN("18446744073709551615");

    before(async () => {
        authority = Keypair.generate();

        const airdrop = await provider.connection.requestAirdrop(
            authority.publicKey,
            5 * LAMPORTS_PER_SOL
        );
        await provider.connection.confirmTransaction(airdrop);

        [statePda] = PublicKey.findProgramAddressSync(
            [Buffer.from("state"), authority.publicKey.toBuffer()],
            program.programId
        );
    });

    describe("Setup: Initialize state", () => {
        it("Initialize state with zero balance", async () => {
            await program.methods
                .initialize()
                .accounts({
                    state: statePda,
                    authority: authority.publicKey,
                    systemProgram: SystemProgram.programId,
                })
                .signers([authority])
                .rpc();

            const state = await program.account.state.fetch(statePda);
            expect(state.balance.toNumber()).to.equal(0);
        });
    });

    describe("Vulnerable: Underflow Attack", () => {
        it("Deposit initial balance", async () => {
            await program.methods
                .vulnerableDeposit(new anchor.BN(100))
                .accounts({
                    state: statePda,
                    authority: authority.publicKey,
                })
                .signers([authority])
                .rpc();

            const state = await program.account.state.fetch(statePda);
            expect(state.balance.toNumber()).to.equal(100);
        });

        it("Underflow: Withdraw more than balance wraps to massive value", async () => {
            // Withdraw 200 when balance is only 100
            await program.methods
                .vulnerableWithdraw(new anchor.BN(200))
                .accounts({
                    state: statePda,
                    authority: authority.publicKey,
                })
                .signers([authority])
                .rpc();

            const state = await program.account.state.fetch(statePda);
            
            // 100 - 200 = -100, which wraps to u64::MAX - 99
            const expectedUnderflow = U64_MAX.sub(new anchor.BN(99));
            expect(state.balance.toString()).to.equal(expectedUnderflow.toString());
        });
    });

    describe("Vulnerable: Overflow Attack", () => {
        it("Overflow: Adding to near-max value wraps to small number", async () => {
            // Current balance is already huge from underflow
            // Adding more will wrap around
            await program.methods
                .vulnerableDeposit(new anchor.BN(200))
                .accounts({
                    state: statePda,
                    authority: authority.publicKey,
                })
                .signers([authority])
                .rpc();

            const state = await program.account.state.fetch(statePda);
            
            // (u64::MAX - 99) + 200 = u64::MAX + 101 = 100 (wrapped)
            expect(state.balance.toNumber()).to.equal(100);
        });
    });

    describe("Secure: Underflow Prevented", () => {
        it("Secure withdraw fails on underflow attempt", async () => {
            // Balance is 100, try to withdraw 200
            try {
                await program.methods
                    .secureWithdraw(new anchor.BN(200))
                    .accounts({
                        state: statePda,
                        authority: authority.publicKey,
                    })
                    .signers([authority])
                    .rpc();

                expect.fail("Should have thrown - underflow");
            } catch (error: any) {
                expect(error.message).to.include("ArithmeticError");
            }
        });

        it("Secure withdraw succeeds with valid amount", async () => {
            const stateBefore = await program.account.state.fetch(statePda);
            
            await program.methods
                .secureWithdraw(new anchor.BN(50))
                .accounts({
                    state: statePda,
                    authority: authority.publicKey,
                })
                .signers([authority])
                .rpc();

            const stateAfter = await program.account.state.fetch(statePda);
            expect(stateAfter.balance.toNumber()).to.equal(
                stateBefore.balance.toNumber() - 50
            );
        });
    });

    describe("Secure: Overflow Prevented", () => {
        it("Set balance near max for overflow test", async () => {
            // First set balance to a known value near max
            const state = await program.account.state.fetch(statePda);
            const currentBalance = state.balance;
            
            // Calculate how much to add to get near max
            const targetBalance = U64_MAX.sub(new anchor.BN(10));
            const toAdd = targetBalance.sub(currentBalance);
            
            // Use vulnerable deposit to set up the state
            await program.methods
                .vulnerableDeposit(toAdd)
                .accounts({
                    state: statePda,
                    authority: authority.publicKey,
                })
                .signers([authority])
                .rpc();
        });

        it("Secure deposit fails on overflow attempt", async () => {
            // Balance is near max, try to add enough to overflow
            try {
                await program.methods
                    .secureDeposit(new anchor.BN(100))
                    .accounts({
                        state: statePda,
                        authority: authority.publicKey,
                    })
                    .signers([authority])
                    .rpc();

                expect.fail("Should have thrown - overflow");
            } catch (error: any) {
                expect(error.message).to.include("ArithmeticError");
            }
        });

        it("Secure deposit succeeds with valid amount", async () => {
            await program.methods
                .secureDeposit(new anchor.BN(5))
                .accounts({
                    state: statePda,
                    authority: authority.publicKey,
                })
                .signers([authority])
                .rpc();

            const state = await program.account.state.fetch(statePda);
            // Balance should be MAX - 10 + 5 = MAX - 5
            const expected = U64_MAX.sub(new anchor.BN(5));
            expect(state.balance.toString()).to.equal(expected.toString());
        });
    });

    describe("Security Comparison", () => {
        it("Demonstrates the core difference", () => {
            console.log("\n=== Integer Overflow/Underflow Security ===\n");

            console.log("VULNERABLE PATTERN:");
            console.log("  state.balance = state.balance.wrapping_sub(amount)");
            console.log("  Risk: 10 - 20 = 18,446,744,073,709,551,606");
            console.log("  Attack: Withdraw more than balance, get quintillions\n");

            console.log("SECURE PATTERN:");
            console.log("  state.balance = state.balance");
            console.log("      .checked_sub(amount)");
            console.log("      .ok_or(ErrorCode::ArithmeticError)?");
            console.log("  Protection: Returns error, transaction fails safely\n");

            console.log("KEY INSIGHT:");
            console.log("  wrapping_* -> SILENT corruption");
            console.log("  checked_* -> SAFE failure");
        });
    });
});
