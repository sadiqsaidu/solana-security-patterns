import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { 
    Keypair, 
    PublicKey, 
    SystemProgram, 
    LAMPORTS_PER_SOL,
} from "@solana/web3.js";
import { expect } from "chai";

describe("05_integer_overflow_state_bug", () => {
    const provider = anchor.AnchorProvider.env();
    anchor.setProvider(provider);

    const program = anchor.workspace.IntegerOverflowStateBug as Program<any>;
    
    // Test accounts
    let poolAuthority: Keypair;
    let staker: Keypair;
    let attacker: Keypair;
    
    // PDAs
    let poolPda: PublicKey;
    let stakerStakePda: PublicKey;
    let attackerStakePda: PublicKey;

    const REWARD_RATE = 1000; // Tokens per second

    before(async () => {
        poolAuthority = Keypair.generate();
        staker = Keypair.generate();
        attacker = Keypair.generate();

        // Airdrop SOL
        for (const keypair of [poolAuthority, staker, attacker]) {
            const airdrop = await provider.connection.requestAirdrop(
                keypair.publicKey,
                5 * LAMPORTS_PER_SOL
            );
            await provider.connection.confirmTransaction(airdrop);
        }

        // Derive PDAs
        [poolPda] = PublicKey.findProgramAddressSync(
            [Buffer.from("pool"), poolAuthority.publicKey.toBuffer()],
            program.programId
        );

        [stakerStakePda] = PublicKey.findProgramAddressSync(
            [Buffer.from("stake"), poolPda.toBuffer(), staker.publicKey.toBuffer()],
            program.programId
        );

        [attackerStakePda] = PublicKey.findProgramAddressSync(
            [Buffer.from("stake"), poolPda.toBuffer(), attacker.publicKey.toBuffer()],
            program.programId
        );
    });

    describe("Setup: Initialize pool and stake accounts", () => {
        it("Initialize staking pool", async () => {
            await program.methods
                .initializePool(new anchor.BN(REWARD_RATE))
                .accounts({
                    pool: poolPda,
                    authority: poolAuthority.publicKey,
                    systemProgram: SystemProgram.programId,
                })
                .signers([poolAuthority])
                .rpc();

            const pool = await program.account.pool.fetch(poolPda);
            console.log(`âœ… Pool initialized with reward rate: ${pool.rewardRate}`);
        });

        it("Initialize stake accounts for staker and attacker", async () => {
            // Initialize staker's stake account
            await program.methods
                .initializeStake()
                .accounts({
                    pool: poolPda,
                    stake: stakerStakePda,
                    owner: staker.publicKey,
                    systemProgram: SystemProgram.programId,
                })
                .signers([staker])
                .rpc();

            // Initialize attacker's stake account
            await program.methods
                .initializeStake()
                .accounts({
                    pool: poolPda,
                    stake: attackerStakePda,
                    owner: attacker.publicKey,
                    systemProgram: SystemProgram.programId,
                })
                .signers([attacker])
                .rpc();

            console.log(`âœ… Stake accounts initialized`);
        });
    });

    describe("âš ï¸  EXPLOIT 1: Underflow via vulnerable_withdraw", () => {
        /**
         * ATTACK EXPLANATION:
         * 
         * The vulnerable_withdraw instruction uses unchecked subtraction.
         * If we withdraw more than we have, it underflows:
         * 
         * 0 - 100 = 18,446,744,073,709,551,516 (u64::MAX - 99)
         * 
         * The attacker suddenly has quintillions of tokens "staked"!
         * 
         * This is similar to the Cashio exploit where arithmetic
         * assumptions led to infinite minting.
         */

        it("First, deposit a small amount to establish stake", async () => {
            await program.methods
                .vulnerableDeposit(new anchor.BN(100))
                .accounts({
                    pool: poolPda,
                    stake: attackerStakePda,
                    owner: attacker.publicKey,
                })
                .signers([attacker])
                .rpc();

            const stake = await program.account.stake.fetch(attackerStakePda);
            console.log(`\nğŸ”§ Attacker deposited: ${stake.amount} tokens`);
        });

        it("âŒ EXPLOIT ATTEMPT: Withdraw more than deposited (underflow)", async () => {
            // Note: In release mode, this would underflow silently
            // In debug mode (anchor test default), Rust panics on overflow
            // This demonstrates why checked math is critical
            
            console.log(`\nğŸ¯ Attack: Attempt to withdraw 200 when only 100 deposited`);
            console.log(`   Expected underflow: 100 - 200 = massive number`);

            try {
                await program.methods
                    .vulnerableWithdraw(new anchor.BN(200))
                    .accounts({
                        pool: poolPda,
                        stake: attackerStakePda,
                        owner: attacker.publicKey,
                    })
                    .signers([attacker])
                    .rpc();

                // If we get here in release mode, check the balance
                const stake = await program.account.stake.fetch(attackerStakePda);
                console.log(`\nğŸš¨ UNDERFLOW SUCCEEDED!`);
                console.log(`   Attacker stake: ${stake.amount.toString()}`);
                
                if (stake.amount.gt(new anchor.BN(1000000))) {
                    console.log(`   This is way more than they ever deposited!`);
                }
            } catch (error: any) {
                // In debug mode, Rust panics on arithmetic overflow
                console.log(`\nâš ï¸  Transaction failed (expected in debug mode)`);
                console.log(`   In RELEASE mode, this would underflow silently!`);
                console.log(`   Error: ${error.message.slice(0, 80)}...`);
            }
        });
    });

    describe("âš ï¸  EXPLOIT 2: Overflow via vulnerable_deposit", () => {
        /**
         * ATTACK EXPLANATION:
         * 
         * If total_staked is close to u64::MAX, adding more can overflow:
         * 
         * (u64::MAX - 50) + 100 = 49  (wraps around!)
         * 
         * This corrupts the pool's accounting completely.
         */

        it("âŒ EXPLOIT: Demonstrate potential overflow in deposit", async () => {
            console.log(`\nğŸ¯ Attack: Overflow in deposit calculation`);
            console.log(`   u64::MAX = 18,446,744,073,709,551,615`);
            console.log(`   If pool had near-max tokens, adding more would wrap to 0`);

            // In a real attack, the attacker would:
            // 1. Find/create a pool near u64::MAX
            // 2. Deposit enough to cause overflow
            // 3. Pool accounting becomes corrupted
            // 4. Exploit the corrupted state

            console.log(`\n   The vulnerable_deposit uses + instead of checked_add`);
            console.log(`   This allows silent overflow in release builds`);
        });
    });

    describe("âš ï¸  EXPLOIT 3: Precision loss in reward calculation", () => {
        /**
         * ATTACK EXPLANATION:
         * 
         * Integer division truncates:
         * (5 / 3) * 1000 = 1 * 1000 = 1000
         * (5 * 1000) / 3 = 5000 / 3 = 1666
         * 
         * The difference of 666 is "free money" for some party!
         * 
         * This is related to how Mango Markets was exploited through
         * oracle manipulation affecting price/reward calculations.
         */

        it("Demonstrate precision loss in division-first calculation", async () => {
            console.log(`\nğŸ¯ Precision Loss Attack:`);
            
            // Simulate the vulnerable calculation
            const rewardRate = 5;
            const totalStaked = 3;
            const timeElapsed = 1000;

            // Vulnerable: divide first
            const vulnerableResult = Math.floor(rewardRate / totalStaked) * timeElapsed;
            
            // Secure: multiply first  
            const secureResult = Math.floor((rewardRate * timeElapsed) / totalStaked);

            console.log(`   Reward rate: ${rewardRate}`);
            console.log(`   Total staked: ${totalStaked}`);
            console.log(`   Time elapsed: ${timeElapsed}`);
            console.log(`\n   Vulnerable (div first): ${vulnerableResult}`);
            console.log(`   Secure (mul first): ${secureResult}`);
            console.log(`   Difference: ${secureResult - vulnerableResult} tokens lost/gained!`);
            
            expect(vulnerableResult).to.not.equal(secureResult);
        });
    });

    describe("âœ… SECURE: Checked arithmetic prevents exploits", () => {
        before(async () => {
            // Reset stake for clean testing
            // In real program, would need to handle this properly
        });

        it("âœ… secure_deposit uses checked_add", async () => {
            await program.methods
                .secureDeposit(new anchor.BN(500))
                .accounts({
                    pool: poolPda,
                    stake: stakerStakePda,
                    owner: staker.publicKey,
                })
                .signers([staker])
                .rpc();

            const stake = await program.account.stake.fetch(stakerStakePda);
            console.log(`\nâœ… Secure deposit: ${stake.amount} tokens`);
            expect(stake.amount.toNumber()).to.equal(500);
        });

        it("âŒ secure_withdraw blocks underflow attempts", async () => {
            try {
                await program.methods
                    .secureWithdraw(new anchor.BN(1000))  // More than deposited
                    .accounts({
                        pool: poolPda,
                        stake: stakerStakePda,
                        owner: staker.publicKey,
                    })
                    .signers([staker])
                    .rpc();

                expect.fail("Should have thrown InsufficientBalance error");
            } catch (error: any) {
                console.log(`\nâœ… Underflow blocked: Insufficient balance check`);
                expect(error.toString()).to.include("InsufficientBalance");
            }
        });

        it("âœ… secure_withdraw succeeds with valid amount", async () => {
            await program.methods
                .secureWithdraw(new anchor.BN(200))
                .accounts({
                    pool: poolPda,
                    stake: stakerStakePda,
                    owner: staker.publicKey,
                })
                .signers([staker])
                .rpc();

            const stake = await program.account.stake.fetch(stakerStakePda);
            console.log(`âœ… Secure withdrawal: remaining ${stake.amount} tokens`);
            expect(stake.amount.toNumber()).to.equal(300);
        });

        it("âŒ secure_compound blocks overflow", async () => {
            // First deposit more
            await program.methods
                .secureDeposit(new anchor.BN(500_000_000))
                .accounts({
                    pool: poolPda,
                    stake: stakerStakePda,
                    owner: staker.publicKey,
                })
                .signers([staker])
                .rpc();

            try {
                // Try to compound with huge multiplier (would exceed max)
                await program.methods
                    .secureCompound(new anchor.BN(100))  // Invalid multiplier
                    .accounts({
                        pool: poolPda,
                        stake: stakerStakePda,
                        owner: staker.publicKey,
                    })
                    .signers([staker])
                    .rpc();

                expect.fail("Should have thrown InvalidMultiplier error");
            } catch (error: any) {
                console.log(`\nâœ… Invalid multiplier blocked`);
                expect(error.toString()).to.include("InvalidMultiplier");
            }
        });

        it("âœ… secure_compound succeeds with valid multiplier", async () => {
            const stakeBefore = await program.account.stake.fetch(stakerStakePda);
            
            await program.methods
                .secureCompound(new anchor.BN(2))
                .accounts({
                    pool: poolPda,
                    stake: stakerStakePda,
                    owner: staker.publicKey,
                })
                .signers([staker])
                .rpc();

            const stakeAfter = await program.account.stake.fetch(stakerStakePda);
            console.log(`âœ… Secure compound: ${stakeBefore.amount} â†’ ${stakeAfter.amount}`);
            expect(stakeAfter.amount.toNumber()).to.equal(stakeBefore.amount.toNumber() * 2);
        });
    });

    describe("ğŸ“Š Security Comparison Summary", () => {
        it("Summary of arithmetic security patterns", () => {
            console.log(`
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                 ARITHMETIC SECURITY COMPARISON SUMMARY                â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  VULNERABLE PATTERNS                                                  â•‘
â•‘  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                  â•‘
â•‘  âŒ a + b         â†’ Overflow wraps to small number                    â•‘
â•‘  âŒ a - b         â†’ Underflow wraps to huge number                    â•‘
â•‘  âŒ a * b         â†’ Overflow possible                                 â•‘
â•‘  âŒ a / b * c     â†’ Precision loss (divide first)                     â•‘
â•‘  âŒ State before validation â†’ Corruption on failure                   â•‘
â•‘                                                                       â•‘
â•‘  REAL-WORLD IMPACT:                                                   â•‘
â•‘  â€¢ Cashio: Infinite mint via arithmetic assumptions ($52.8M)          â•‘
â•‘  â€¢ Nirvana: Flash loan exploited pricing calculation ($3.5M)          â•‘
â•‘  â€¢ Mango: Oracle manipulation affected balances ($116M)               â•‘
â•‘                                                                       â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  SECURE PATTERNS                                                      â•‘
â•‘  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                      â•‘
â•‘  âœ… a.checked_add(b).ok_or(Error)?   â†’ Returns None on overflow       â•‘
â•‘  âœ… a.checked_sub(b).ok_or(Error)?   â†’ Returns None on underflow      â•‘
â•‘  âœ… a.checked_mul(b).ok_or(Error)?   â†’ Returns None on overflow       â•‘
â•‘  âœ… (a * c) / b                      â†’ Multiply before divide         â•‘
â•‘  âœ… u128 intermediates               â†’ Prevent intermediate overflow  â•‘
â•‘  âœ… Validate â†’ Calculate â†’ Update    â†’ Atomic state changes           â•‘
â•‘                                                                       â•‘
â•‘  ALSO CONSIDER:                                                       â•‘
â•‘  â€¢ saturating_add/sub for bounded values                              â•‘
â•‘  â€¢ wrapping_* when overflow is intentional                            â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

KEY FORMULAS:
  Reward calculation (secure):
    let result = (amount as u128)
        .checked_mul(rate as u128)?
        .checked_mul(time as u128)?
        .checked_div(total as u128)?;
    require!(result <= u64::MAX as u128);
            `);
        });
    });
});
