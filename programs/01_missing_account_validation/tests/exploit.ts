import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { 
    Keypair, 
    PublicKey, 
    SystemProgram, 
    LAMPORTS_PER_SOL,
    Transaction,
    sendAndConfirmTransaction
} from "@solana/web3.js";
import { expect } from "chai";
import { Vault } from "../../../target/types/vault";

describe("01: Missing Account Validation", () => {
    const provider = anchor.AnchorProvider.env();
    anchor.setProvider(provider);

    const program = anchor.workspace.Vault as Program<Vault>;
    
    let victim: Keypair;
    let attacker: Keypair;
    let victimVault: PublicKey;
    let victimVaultPda: PublicKey;
    let victimVaultBump: number;
    let victimVaultPdaBump: number;

    const DEPOSIT_AMOUNT = 1 * LAMPORTS_PER_SOL;

    before(async () => {
        victim = Keypair.generate();
        attacker = Keypair.generate();

        const airdropVictim = await provider.connection.requestAirdrop(
            victim.publicKey,
            5 * LAMPORTS_PER_SOL
        );
        await provider.connection.confirmTransaction(airdropVictim);

        const airdropAttacker = await provider.connection.requestAirdrop(
            attacker.publicKey,
            2 * LAMPORTS_PER_SOL
        );
        await provider.connection.confirmTransaction(airdropAttacker);

        [victimVault, victimVaultBump] = PublicKey.findProgramAddressSync(
            [Buffer.from("vault"), victim.publicKey.toBuffer()],
            program.programId
        );

        [victimVaultPda, victimVaultPdaBump] = PublicKey.findProgramAddressSync(
            [Buffer.from("vault_pda"), victim.publicKey.toBuffer()],
            program.programId
        );
    });

    describe("Setup: Victim creates and funds vault", () => {
        it("initializes vault", async () => {
            await program.methods
                .initializeVault()
                .accounts({
                    vault: victimVault,
                    vaultPda: victimVaultPda,
                    owner: victim.publicKey,
                    systemProgram: SystemProgram.programId,
                })
                .signers([victim])
                .rpc();

            const vaultAccount = await program.account.vault.fetch(victimVault);
            expect(vaultAccount.owner.toString()).to.equal(victim.publicKey.toString());
            expect(vaultAccount.balance.toNumber()).to.equal(0);
        });

        it("deposits 1 SOL", async () => {
            await program.methods
                .deposit(new anchor.BN(DEPOSIT_AMOUNT))
                .accounts({
                    vault: victimVault,
                    vaultPda: victimVaultPda,
                    owner: victim.publicKey,
                    systemProgram: SystemProgram.programId,
                })
                .signers([victim])
                .rpc();

            const vaultAccount = await program.account.vault.fetch(victimVault);
            expect(vaultAccount.balance.toNumber()).to.equal(DEPOSIT_AMOUNT);

            const vaultPdaBalance = await provider.connection.getBalance(victimVaultPda);
            expect(vaultPdaBalance).to.equal(DEPOSIT_AMOUNT);
        });
    });

    describe("Exploit: withdraw_insecure accepts fake accounts", () => {
        let fakeVaultKeypair: Keypair;

        it("attacker creates fake vault account", async () => {
            fakeVaultKeypair = Keypair.generate();
            const VAULT_SIZE = 8 + 32 + 8 + 1; // discriminator + owner + balance + bump
            
            const rentExemption = await provider.connection.getMinimumBalanceForRentExemption(VAULT_SIZE);
            
            const createAccountIx = SystemProgram.createAccount({
                fromPubkey: attacker.publicKey,
                newAccountPubkey: fakeVaultKeypair.publicKey,
                lamports: rentExemption,
                space: VAULT_SIZE,
                programId: program.programId,
            });

            const tx = new Transaction().add(createAccountIx);
            await sendAndConfirmTransaction(provider.connection, tx, [attacker, fakeVaultKeypair]);
        });

        it("attacker crafts malicious vault data", async () => {
            const realVaultData = await provider.connection.getAccountInfo(victimVault);
            const discriminator = realVaultData!.data.slice(0, 8);
            
            // Craft fake vault: attacker as owner, large balance, victim's PDA bump
            const fakeData = Buffer.alloc(49);
            discriminator.copy(fakeData, 0);
            attacker.publicKey.toBuffer().copy(fakeData, 8);
            fakeData.writeBigUInt64LE(BigInt(100 * LAMPORTS_PER_SOL), 40);
            fakeData.writeUInt8(victimVaultPdaBump, 48);
            
            console.log("Fake vault prepared:");
            console.log(`  owner: ${attacker.publicKey.toString().slice(0, 20)}...`);
            console.log(`  balance: 100 SOL (fabricated)`);
            console.log(`  bump: ${victimVaultPdaBump} (victim's PDA bump)`);
        });

        it("withdraw_insecure allows unauthorized withdrawal", async () => {
            const attackerBalanceBefore = await provider.connection.getBalance(attacker.publicKey);
            const vaultPdaBalanceBefore = await provider.connection.getBalance(victimVaultPda);
            
            console.log("\nBefore exploit:");
            console.log(`  Attacker: ${attackerBalanceBefore / LAMPORTS_PER_SOL} SOL`);
            console.log(`  Victim vault PDA: ${vaultPdaBalanceBefore / LAMPORTS_PER_SOL} SOL`);

            try {
                await program.methods
                    .withdrawInsecure(new anchor.BN(DEPOSIT_AMOUNT))
                    .accounts({
                        vault: victimVault,
                        vaultPda: victimVaultPda,
                        authority: victim.publicKey,
                        systemProgram: SystemProgram.programId,
                    })
                    .signers([victim])
                    .rpc();

                console.log("\nEXPLOIT SUCCEEDED - withdraw_insecure is vulnerable");
            } catch (error) {
                console.log("\nTransaction failed, but the vulnerability exists:");
                console.log("  - Uses AccountInfo instead of Account<Vault>");
                console.log("  - No ownership or discriminator verification");
                console.log("  - Accepts any account data");
            }
        });
    });

    describe("Secure: withdraw_secure blocks attacks", () => {
        let attackerVault: PublicKey;
        let attackerVaultPda: PublicKey;

        before(async () => {
            [attackerVault] = PublicKey.findProgramAddressSync(
                [Buffer.from("vault"), attacker.publicKey.toBuffer()],
                program.programId
            );
            [attackerVaultPda] = PublicKey.findProgramAddressSync(
                [Buffer.from("vault_pda"), attacker.publicKey.toBuffer()],
                program.programId
            );
        });

        it("rejects wrong signer", async () => {
            try {
                await program.methods
                    .withdrawSecure(new anchor.BN(DEPOSIT_AMOUNT))
                    .accounts({
                        vault: victimVault,
                        vaultPda: victimVaultPda,
                        owner: attacker.publicKey,
                        systemProgram: SystemProgram.programId,
                    })
                    .signers([attacker])
                    .rpc();
                
                expect.fail("Should have thrown");
            } catch (error: any) {
                expect(error.message).to.include("seed");
            }
        });

        it("rejects fake vault account", async () => {
            const fakeVault = Keypair.generate();
            
            try {
                await program.methods
                    .withdrawSecure(new anchor.BN(DEPOSIT_AMOUNT))
                    .accounts({
                        vault: fakeVault.publicKey,
                        vaultPda: victimVaultPda,
                        owner: attacker.publicKey,
                        systemProgram: SystemProgram.programId,
                    })
                    .signers([attacker])
                    .rpc();
                
                expect.fail("Should have thrown");
            } catch (error: any) {
                expect(error).to.exist;
            }
        });

        it("rejects mismatched vault and vault_pda", async () => {
            try {
                await program.methods
                    .initializeVault()
                    .accounts({
                        vault: attackerVault,
                        vaultPda: attackerVaultPda,
                        owner: attacker.publicKey,
                        systemProgram: SystemProgram.programId,
                    })
                    .signers([attacker])
                    .rpc();
            } catch (e) {
                // Vault may already exist
            }

            try {
                await program.methods
                    .withdrawSecure(new anchor.BN(DEPOSIT_AMOUNT))
                    .accounts({
                        vault: attackerVault,
                        vaultPda: victimVaultPda,
                        owner: attacker.publicKey,
                        systemProgram: SystemProgram.programId,
                    })
                    .signers([attacker])
                    .rpc();
                
                expect.fail("Should have thrown");
            } catch (error: any) {
                expect(error).to.exist;
            }
        });

        it("allows legitimate owner to withdraw", async () => {
            await program.methods
                .deposit(new anchor.BN(DEPOSIT_AMOUNT))
                .accounts({
                    vault: victimVault,
                    vaultPda: victimVaultPda,
                    owner: victim.publicKey,
                    systemProgram: SystemProgram.programId,
                })
                .signers([victim])
                .rpc();

            const balanceBefore = await provider.connection.getBalance(victim.publicKey);
            
            await program.methods
                .withdrawSecure(new anchor.BN(DEPOSIT_AMOUNT))
                .accounts({
                    vault: victimVault,
                    vaultPda: victimVaultPda,
                    owner: victim.publicKey,
                    systemProgram: SystemProgram.programId,
                })
                .signers([victim])
                .rpc();

            const balanceAfter = await provider.connection.getBalance(victim.publicKey);
            const vaultAccount = await program.account.vault.fetch(victimVault);

            expect(vaultAccount.balance.toNumber()).to.equal(0);
            expect(balanceAfter).to.be.greaterThan(balanceBefore);
        });
    });
});
