import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { Keypair, LAMPORTS_PER_SOL, PublicKey, SystemProgram } from "@solana/web3.js";
import { expect } from "chai";

describe("03_incorrect_pda_derivation", () => {
    const provider = anchor.AnchorProvider.env();
    anchor.setProvider(provider);

    const program = anchor.workspace.IncorrectPdaDerivation as Program<any>;

    let victim: Keypair;
    let attacker: Keypair;

    before(async () => {
        victim = Keypair.generate();
        attacker = Keypair.generate();

        for (const keypair of [victim, attacker]) {
            const airdrop = await provider.connection.requestAirdrop(
                keypair.publicKey,
                5 * LAMPORTS_PER_SOL
            );
            await provider.connection.confirmTransaction(airdrop);
        }
    });

    describe("Vulnerable: Username Squatting Attack", () => {
        const targetUsername = "alice";

        it("Attacker frontruns and claims victim's desired username", async () => {
            // Attacker derives PDA for target username
            const [profilePda] = PublicKey.findProgramAddressSync(
                [Buffer.from("profile"), Buffer.from(targetUsername)],
                program.programId
            );

            // Attacker claims the username before victim
            await program.methods
                .vulnerableCreateProfile(targetUsername)
                .accounts({
                    profile: profilePda,
                    payer: attacker.publicKey,
                    systemProgram: SystemProgram.programId,
                })
                .signers([attacker])
                .rpc();

            const profile = await program.account.profile.fetch(profilePda);

            // Attacker now owns the profile
            expect(profile.authority.toString()).to.equal(attacker.publicKey.toString());
            expect(profile.username).to.equal(targetUsername);
        });

        it("Victim cannot create profile with squatted username", async () => {
            const [profilePda] = PublicKey.findProgramAddressSync(
                [Buffer.from("profile"), Buffer.from(targetUsername)],
                program.programId
            );

            try {
                await program.methods
                    .vulnerableCreateProfile(targetUsername)
                    .accounts({
                        profile: profilePda,
                        payer: victim.publicKey,
                        systemProgram: SystemProgram.programId,
                    })
                    .signers([victim])
                    .rpc();

                expect.fail("Should have thrown - account already exists");
            } catch (error: any) {
                // Account already initialized by attacker
                expect(error.message).to.include("already in use");
            }
        });
    });

    describe("Secure: Authority-Based PDA Derivation", () => {
        const username = "alice";

        it("Each user gets unique profile regardless of username", async () => {
            // PDAs derived from user public keys - completely independent
            const [victimPda] = PublicKey.findProgramAddressSync(
                [Buffer.from("profile_secure"), victim.publicKey.toBuffer()],
                program.programId
            );

            const [attackerPda] = PublicKey.findProgramAddressSync(
                [Buffer.from("profile_secure"), attacker.publicKey.toBuffer()],
                program.programId
            );

            // Both can use the same username - it's just data now
            await program.methods
                .secureCreateProfile(username)
                .accounts({
                    profile: victimPda,
                    authority: victim.publicKey,
                    systemProgram: SystemProgram.programId,
                })
                .signers([victim])
                .rpc();

            await program.methods
                .secureCreateProfile(username)
                .accounts({
                    profile: attackerPda,
                    authority: attacker.publicKey,
                    systemProgram: SystemProgram.programId,
                })
                .signers([attacker])
                .rpc();

            const victimProfile = await program.account.profile.fetch(victimPda);
            const attackerProfile = await program.account.profile.fetch(attackerPda);

            // Each owns their own profile
            expect(victimProfile.authority.toString()).to.equal(victim.publicKey.toString());
            expect(attackerProfile.authority.toString()).to.equal(attacker.publicKey.toString());

            // Both have same username - no conflict
            expect(victimProfile.username).to.equal(username);
            expect(attackerProfile.username).to.equal(username);

            // Different PDAs
            expect(victimPda.toString()).to.not.equal(attackerPda.toString());
        });

        it("Attacker cannot create profile for victim's PDA", async () => {
            const newVictim = Keypair.generate();
            const airdrop = await provider.connection.requestAirdrop(
                newVictim.publicKey,
                2 * LAMPORTS_PER_SOL
            );
            await provider.connection.confirmTransaction(airdrop);

            const [victimPda] = PublicKey.findProgramAddressSync(
                [Buffer.from("profile_secure"), newVictim.publicKey.toBuffer()],
                program.programId
            );

            try {
                // Attacker tries to create profile at victim's PDA
                await program.methods
                    .secureCreateProfile("stolen")
                    .accounts({
                        profile: victimPda,
                        authority: attacker.publicKey,
                        systemProgram: SystemProgram.programId,
                    })
                    .signers([attacker])
                    .rpc();

                expect.fail("Should have thrown - seeds don't match");
            } catch (error: any) {
                // PDA derivation mismatch
                expect(error.message).to.include("seeds");
            }
        });
    });

    describe("Security Comparison", () => {
        it("Demonstrates the core difference", () => {
            console.log("\n=== PDA Derivation Security ===\n");

            console.log("VULNERABLE PATTERN:");
            console.log("  seeds = [b'profile', username.as_bytes()]");
            console.log("  Risk: Anyone can claim any username first");
            console.log("  Attack: Frontrun mempool, squat popular names\n");

            console.log("SECURE PATTERN:");
            console.log("  seeds = [b'profile_secure', authority.key().as_ref()]");
            console.log("  Protection: PDA tied to signer's identity");
            console.log("  Result: Each user has unique, unforgeable namespace\n");

            console.log("KEY INSIGHT:");
            console.log("  User-controlled strings -> STORED DATA");
            console.log("  User public keys -> PDA SEEDS");
        });
    });
});
