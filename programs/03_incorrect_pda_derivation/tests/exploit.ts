import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { 
    Keypair, 
    PublicKey, 
    SystemProgram, 
    LAMPORTS_PER_SOL,
} from "@solana/web3.js";
import { expect } from "chai";

describe("03_incorrect_pda_derivation", () => {
    const provider = anchor.AnchorProvider.env();
    anchor.setProvider(provider);

    const program = anchor.workspace.IncorrectPdaDerivation as Program<any>;
    
    // Test accounts
    let victim: Keypair;
    let attacker: Keypair;
    let recipient: Keypair;

    before(async () => {
        victim = Keypair.generate();
        attacker = Keypair.generate();
        recipient = Keypair.generate();

        // Airdrop SOL
        for (const keypair of [victim, attacker]) {
            const airdrop = await provider.connection.requestAirdrop(
                keypair.publicKey,
                5 * LAMPORTS_PER_SOL
            );
            await provider.connection.confirmTransaction(airdrop);
        }
    });

    describe("âš ï¸  EXPLOIT 1: Username Squatting via vulnerable_create_profile", () => {
        /**
         * ATTACK EXPLANATION:
         * 
         * The vulnerable_create_profile instruction derives PDA from username string.
         * This allows attackers to "squat" on usernames before legitimate users.
         * 
         * Attack flow:
         * 1. Victim wants username "alice"
         * 2. Attacker frontruns and creates profile with username "alice"
         * 3. Attacker now controls the PDA that victim would have used
         * 4. Victim cannot create profile with their desired username
         * 
         * This is similar to the Crema Finance attack where fake tick accounts
         * were created to intercept protocol operations.
         */

        const desiredUsername = "popular_username";

        it("âŒ EXPLOIT: Attacker squats on victim's desired username", async () => {
            // Derive the PDA for this username
            const [profilePda] = PublicKey.findProgramAddressSync(
                [Buffer.from("profile"), Buffer.from(desiredUsername)],
                program.programId
            );

            console.log(`\nğŸ¯ Attack: Username squatting`);
            console.log(`   Target username: "${desiredUsername}"`);
            console.log(`   Profile PDA: ${profilePda}`);

            // Attacker creates profile with victim's desired username
            await program.methods
                .vulnerableCreateProfile(desiredUsername)
                .accounts({
                    profile: profilePda,
                    payer: attacker.publicKey,
                    systemProgram: SystemProgram.programId,
                })
                .signers([attacker])
                .rpc();

            // Verify attacker owns the profile
            const profile = await program.account.profile.fetch(profilePda);
            
            console.log(`\nğŸš¨ EXPLOIT SUCCEEDED!`);
            console.log(`   Profile owner: ${profile.authority}`);
            console.log(`   Attacker: ${attacker.publicKey}`);
            console.log(`   Username "${desiredUsername}" is now controlled by attacker!`);

            expect(profile.authority.toString()).to.equal(attacker.publicKey.toString());
        });

        it("âŒ Victim cannot create profile with squatted username", async () => {
            const [profilePda] = PublicKey.findProgramAddressSync(
                [Buffer.from("profile"), Buffer.from(desiredUsername)],
                program.programId
            );

            try {
                await program.methods
                    .vulnerableCreateProfile(desiredUsername)
                    .accounts({
                        profile: profilePda,
                        payer: victim.publicKey,
                        systemProgram: SystemProgram.programId,
                    })
                    .signers([victim])
                    .rpc();

                expect.fail("Should have failed - username is squatted");
            } catch (error: any) {
                console.log(`\nâœ… Victim blocked: Username already taken by attacker`);
                // Account already exists error
                expect(error).to.exist;
            }
        });
    });

    describe("âœ… SECURE: Username squatting prevented with secure_create_profile", () => {
        /**
         * SECURE APPROACH:
         * 
         * PDA is derived from the user's pubkey, not username.
         * Username is just data stored in the profile.
         * 
         * Benefits:
         * - Each user can only have ONE profile
         * - No frontrunning possible
         * - Username is just display data, not identity
         */

        it("âœ… Each user gets their own unique profile", async () => {
            // Victim's profile PDA (derived from their pubkey)
            const [victimProfilePda] = PublicKey.findProgramAddressSync(
                [Buffer.from("profile"), victim.publicKey.toBuffer()],
                program.programId
            );

            // Attacker's profile PDA (derived from their pubkey)
            const [attackerProfilePda] = PublicKey.findProgramAddressSync(
                [Buffer.from("profile"), attacker.publicKey.toBuffer()],
                program.programId
            );

            console.log(`\nğŸ›¡ï¸  Secure profile creation:`);
            console.log(`   Victim PDA: ${victimProfilePda}`);
            console.log(`   Attacker PDA: ${attackerProfilePda}`);

            // Both can create profiles with any username they want
            await program.methods
                .secureCreateProfile("alice")  // Victim can use "alice"
                .accounts({
                    profile: victimProfilePda,
                    authority: victim.publicKey,
                    systemProgram: SystemProgram.programId,
                })
                .signers([victim])
                .rpc();

            await program.methods
                .secureCreateProfile("alice")  // Attacker can ALSO use "alice" - it's just display data
                .accounts({
                    profile: attackerProfilePda,
                    authority: attacker.publicKey,
                    systemProgram: SystemProgram.programId,
                })
                .signers([attacker])
                .rpc();

            const victimProfile = await program.account.profile.fetch(victimProfilePda);
            const attackerProfile = await program.account.profile.fetch(attackerProfilePda);

            console.log(`\nâœ… Both profiles created successfully:`);
            console.log(`   Victim's profile: authority=${victimProfile.authority}, username="${victimProfile.username}"`);
            console.log(`   Attacker's profile: authority=${attackerProfile.authority}, username="${attackerProfile.username}"`);

            // Each owns their own profile
            expect(victimProfile.authority.toString()).to.equal(victim.publicKey.toString());
            expect(attackerProfile.authority.toString()).to.equal(attacker.publicKey.toString());
        });

        it("âŒ Attacker cannot create profile for victim (wrong signer)", async () => {
            // Attacker tries to create a profile at victim's PDA
            const [victimProfilePda] = PublicKey.findProgramAddressSync(
                [Buffer.from("profile"), victim.publicKey.toBuffer()],
                program.programId
            );

            try {
                await program.methods
                    .secureCreateProfile("hijacked")
                    .accounts({
                        profile: victimProfilePda,
                        authority: victim.publicKey,  // Victim's pubkey
                    })
                    .signers([attacker])  // But attacker signs
                    .rpc();

                expect.fail("Should have failed");
            } catch (error: any) {
                console.log(`\nâœ… Attack blocked: Cannot create profile for another user`);
                expect(error.message).to.include("unknown signer");
            }
        });
    });

    describe("âš ï¸  EXPLOIT 2: Pool name collision via vulnerable_create_pool", () => {
        /**
         * ATTACK EXPLANATION:
         * 
         * The vulnerable_create_pool uses only pool_name as seed.
         * First creator "owns" the pool name for the entire program.
         * 
         * This could lead to:
         * 1. Pool name squatting (like domain squatting)
         * 2. Confusion between pools from different authorities
         */

        it("âŒ EXPLOIT: First user claims pool name for everyone", async () => {
            const poolName = "main-liquidity";

            const [poolPda] = PublicKey.findProgramAddressSync(
                [Buffer.from("pool"), Buffer.from(poolName)],
                program.programId
            );

            console.log(`\nğŸ¯ Attack: Pool name squatting`);

            // Attacker creates the pool first
            await program.methods
                .vulnerableCreatePool(poolName)
                .accounts({
                    pool: poolPda,
                    authority: attacker.publicKey,
                    systemProgram: SystemProgram.programId,
                })
                .signers([attacker])
                .rpc();

            const pool = await program.account.pool.fetch(poolPda);
            console.log(`\nğŸš¨ Attacker claimed pool "${poolName}"`);
            console.log(`   Pool authority: ${pool.authority}`);

            // Victim cannot create pool with same name
            try {
                await program.methods
                    .vulnerableCreatePool(poolName)
                    .accounts({
                        pool: poolPda,
                        authority: victim.publicKey,
                        systemProgram: SystemProgram.programId,
                    })
                    .signers([victim])
                    .rpc();

                expect.fail("Should have failed");
            } catch (error) {
                console.log(`   Victim cannot create pool with same name!`);
            }
        });
    });

    describe("âœ… SECURE: Each authority has unique pool namespace", () => {
        it("âœ… Both users can create pools with same name", async () => {
            const poolName = "my-pool";

            // Each authority has their own namespace
            const [victimPoolPda] = PublicKey.findProgramAddressSync(
                [Buffer.from("pool"), victim.publicKey.toBuffer(), Buffer.from(poolName)],
                program.programId
            );

            const [attackerPoolPda] = PublicKey.findProgramAddressSync(
                [Buffer.from("pool"), attacker.publicKey.toBuffer(), Buffer.from(poolName)],
                program.programId
            );

            console.log(`\nğŸ›¡ï¸  Secure pool creation:`);
            console.log(`   Same pool name: "${poolName}"`);
            console.log(`   Victim's pool PDA: ${victimPoolPda}`);
            console.log(`   Attacker's pool PDA: ${attackerPoolPda}`);

            // Both can create pools with the same name
            await program.methods
                .secureCreatePool(poolName)
                .accounts({
                    pool: victimPoolPda,
                    authority: victim.publicKey,
                    systemProgram: SystemProgram.programId,
                })
                .signers([victim])
                .rpc();

            await program.methods
                .secureCreatePool(poolName)
                .accounts({
                    pool: attackerPoolPda,
                    authority: attacker.publicKey,
                    systemProgram: SystemProgram.programId,
                })
                .signers([attacker])
                .rpc();

            console.log(`\nâœ… Both pools created - no collision!`);

            // Different PDAs for same pool name
            expect(victimPoolPda.toString()).to.not.equal(attackerPoolPda.toString());
        });
    });

    describe("âš ï¸  EXPLOIT 3: Escrow manipulation via non-canonical bump", () => {
        /**
         * ATTACK EXPLANATION:
         * 
         * If a program stores user-provided bumps instead of canonical bumps,
         * an attacker might be able to create "duplicate" PDAs with different bumps.
         * 
         * Note: Anchor's seeds constraint uses canonical bump for derivation,
         * but the STORED bump being wrong can cause issues in subsequent access.
         */

        it("âš ï¸  Demonstrates the danger of storing non-canonical bumps", async () => {
            const escrowId = new anchor.BN(12345);

            // Find canonical bump
            const [escrowPda, canonicalBump] = PublicKey.findProgramAddressSync(
                [
                    Buffer.from("escrow"),
                    attacker.publicKey.toBuffer(),
                    recipient.publicKey.toBuffer(),
                    escrowId.toArrayLike(Buffer, "le", 8)
                ],
                program.programId
            );

            console.log(`\nğŸ¯ PDA bump analysis:`);
            console.log(`   Canonical bump: ${canonicalBump}`);

            // Create escrow (Anchor uses canonical bump for derivation)
            await program.methods
                .vulnerableCreateEscrow(escrowId, canonicalBump)
                .accounts({
                    escrow: escrowPda,
                    creator: attacker.publicKey,
                    recipient: recipient.publicKey,
                    systemProgram: SystemProgram.programId,
                })
                .signers([attacker])
                .rpc();

            const escrow = await program.account.escrow.fetch(escrowPda);
            console.log(`   Stored bump: ${escrow.bump}`);
            console.log(`\nâš ï¸  If stored bump differs from canonical, future access could fail`);
            console.log(`   Always use ctx.bumps.* to get canonical bump!`);
        });
    });

    describe("âœ… SECURE: Canonical bump ensures consistent PDA access", () => {
        it("âœ… Secure escrow uses canonical bump from Anchor", async () => {
            const escrowId = new anchor.BN(99999);

            const [escrowPda, canonicalBump] = PublicKey.findProgramAddressSync(
                [
                    Buffer.from("escrow"),
                    victim.publicKey.toBuffer(),
                    recipient.publicKey.toBuffer(),
                    escrowId.toArrayLike(Buffer, "le", 8)
                ],
                program.programId
            );

            // Create escrow securely
            await program.methods
                .secureCreateEscrow(escrowId)
                .accounts({
                    escrow: escrowPda,
                    creator: victim.publicKey,
                    recipient: recipient.publicKey,
                    systemProgram: SystemProgram.programId,
                })
                .signers([victim])
                .rpc();

            // Deposit to escrow
            await program.methods
                .secureDepositToEscrow(new anchor.BN(1000))
                .accounts({
                    escrow: escrowPda,
                    creator: victim.publicKey,
                })
                .signers([victim])
                .rpc();

            const escrow = await program.account.escrow.fetch(escrowPda);

            console.log(`\nâœ… Secure escrow created and accessed:`);
            console.log(`   Canonical bump: ${canonicalBump}`);
            console.log(`   Stored bump: ${escrow.bump}`);
            console.log(`   Amount deposited: ${escrow.amount}`);

            expect(escrow.bump).to.equal(canonicalBump);
            expect(escrow.amount.toNumber()).to.equal(1000);
        });
    });

    describe("ğŸ“Š Security Comparison Summary", () => {
        it("Summary of PDA derivation patterns", () => {
            console.log(`
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    PDA DERIVATION SECURITY SUMMARY                    â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  VULNERABLE PATTERNS                                                  â•‘
â•‘  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                  â•‘
â•‘  âŒ User-controlled string as seed (username squatting)               â•‘
â•‘  âŒ Missing authority in seeds (global namespace collision)           â•‘
â•‘  âŒ User-provided bump (non-canonical bump storage)                   â•‘
â•‘                                                                       â•‘
â•‘  REAL-WORLD IMPACT:                                                   â•‘
â•‘  â€¢ Crema Finance: Fake tick accounts ($8.8M)                          â•‘
â•‘  â€¢ Wormhole: Spoofed signature accounts ($326M)                       â•‘
â•‘  â€¢ Cashio: Fake collateral derivation ($52.8M)                        â•‘
â•‘                                                                       â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  SECURE PATTERNS                                                      â•‘
â•‘  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                      â•‘
â•‘  âœ… Include authority pubkey in all seeds                              â•‘
â•‘  âœ… Use program-specific prefixes                                      â•‘
â•‘  âœ… Store canonical bump from ctx.bumps.*                              â•‘
â•‘  âœ… Verify PDA derivation on subsequent access                         â•‘
â•‘                                                                       â•‘
â•‘  SEED FORMULA: [prefix, authority.key(), unique_id]                   â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            `);
        });
    });
});
